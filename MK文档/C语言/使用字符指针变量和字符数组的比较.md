## 使用字符指针变量和字符数组的比较

用字符数组和字符指针变量都能实现字符串的储存和运算，但它们二者之间是有区别的，不该混为一谈

主要有以下几点:

(1) **字符数组**由若干个元素组成，每个元素中放一个字符，而**字符指针变量**变量中存放的是地址(字符串第1个字符的地址)，绝不是将字符串放到字符指针变量中

(2) 赋值方式:可以对字符指针变量赋值，但不能对数组名赋值

可以采用下面方法对字符指针变量赋值

```
char * a;				// a为字符指针变量
a="I love China!";	   // 将字符串元素地址赋给指针变量，合法
// 但赋给a的不是字符串，而是字符串的第一个地址
```
不能用以下办法对字符数组名赋值
```
char str[14];
str[0]='I';  			// 对字符数组元素赋值 合法
str="I love China!";     // 数组名是地址，是常量，不能被赋值，非法
```
(3)初始化的含义，对字符指针变量赋初值:
```
char *a = "I love China"; // 定义字符指针变量a，并把字符串第一个元素的地址赋给a
```
等价于
```
char *a;				// 定义字符指针a
a = "I love China!";	// 把字符串第一个元素赋值给a
```
而对数组的初始化
```
char str[14] = "I love China"; // 定义字符数组str，并把字符串赋给数组中各元素
```
不等价于
```
char str[14];			// 定义字符数组str
str[] ="I love China!";  // 企图把字符串赋给数组中的各元素
```
**数组可以在定义时对各元素赋初值，但不能赋值语句对字符数组中全部元素整体赋值**
(4) 存储单元的内容。编译时为字符数组分配若干单元，以存放个元素的值，而对字符指针变量，只分配一个储存单元(Visual C++ 为指针变量分配4个字节)

如果定义了字符数组，但未对它赋值，这时数组中的元素的值是不可预料的，可以引用这些值，显然是无意义的
如果定义了字符指针变量，应及时把一个字符变量或字符数组元素的地址赋值给它，使它指向一个字符型数据，如果未对它赋予一个地址的值，它并未具体指向一个确定的对象，此时如果向该指针变量所指向的对象输入数据，可能会出现严重的结果 。常有人用此方法
```
char *a;			// 定义字符指针变量a
scanf("%s",a);	  // 企图从键盘输入一个字符串，使a指向该字符串，错误
```

在Visual C++ 编译会发出 **警告** 信息，提醒未给指针变量指定初始值(未指定其指向)，虽然也勉强运行，但这种方法是危险的。因为编译时给指针变量a分配了储存单元，变量a的地址(即&a)是已经制定了，但a并未被赋值，在a的储存单元中是一个不可预料的值，在执行scanf函数时，要求将一个字符串输入到a所指向的一段储存单元(即以a的值是一个地址)开始的一段内存单元)中。而a的值如今却是不可预料的，它可能指向内存中空白的(未用的)用户存储区，也可能指向已经存放指令或数据的有用内存，这就破坏了程序或有用的数据，甚至会破坏了系统，会造成了严重的后果。应当绝对防止这种情况的出现。应当在定义指针变量后，及时指定其指向。如

```
char *a,str[10];	// 定义了字符指针变量a和字符数组str
a = str;			// 使a指向str数组和首元素
scanf("%s",a);	  // 从键盘输入一个字符串存放到a所指向的后一段储存单元中，正确
```
先使a有确定值，使a指向一个数组元素，然后输入一个字符串，把它存放在以该地址开始的若干单元中。
**(5)指针变量的值是可以改变的，而字符数组名代表一个固定的值(数组首元素的地址)，不能改变**

```
#include<stdio.h>

int main(){
	char *a = "I love China!";
	a=a+7;						// 改变指针变量的值，即改变指针变量的指向 
	printf("%s\n",a);			// 输出从a指向的字符开始的字符串 
	return 0;
}
```

**运行效果**
`China!`


**程序分析**:指针变量a的值是可以变化的，从指针变量a当时所指向的元素开始，逐个输出各个字符，直到遇见'\0'为止，而数组名虽然代表地址，但它是常量，它的值是不能改变的，下面说法是错误的:

```
char str[]={"I love China"};
str = str + 7;
printf("%s",str);
```
(6)字符数组中各元素的值可以改变的，但指针变量指向的字符串常量中的内容是不可以取代的

```
char a[] = "House"; // 字符数组初始化
char *b = "House";  // 字符指针变量b指向字符串常量的第一个字符
a[2] = 'r';         // 合法 r取代a数组元素a[2]的原值u
b[2] = 'r';         // 非法，字符串常量不能改变

```
(7)引用数组元素，对字符数组可以用下标法(用数组名和下标)引用一个数组元素如 a[5],也可以用地址法`*(a+5)`引用数组元素`a[5]`。如果定义了字符指针变量p，并使它指向数组a的首元素，则可以用指针变量带下标的形式引用数组元素(如p[5])，同样，可以用地址法(如`*(p+5)`)引用数组元素`a[5]`

但是，如果指针变量没有没有指向数组，则无法使用`p[5]`或者`*(p+5)`这样的形式引用数组中的元素。这时若输出p[5]或者*(p+5)这样的形式引用数组中的元素,系统将输出指针变量p所指的字符后边五个字符的内容，显然是没有意义的，应当避免出现这种情况。

若字符指针变量p指向字符串常量，就可以用指针变量带下标的形式引用所指的字符串中的字符。如有
```
char *a="I love China" // 定义指针变量a，指向字符串常量
```
则`a[5]`的值是a所指向的字符串"I love China!"中第六个字符序号是5 即字母'e'

虽然未定义数组a，但是字符串在内存中是以字符数组形式存放的。a[5]按*(a+5)处理，即从a当前所指向的元素下移5个元素位置，取出其单元的值。

(8)用指针变量指向一个格式字符串，可以用它代替printf函数中的格式字符串。例如
char * format;
```
format = "a=%d,b=%f\n"; // 使format指向一个字符串
printf ...
```



















